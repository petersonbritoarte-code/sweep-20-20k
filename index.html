<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
 <title>Frequência 20/20 — Prof. Peterson Brito</title>

<!-- Open Graph / WhatsApp / Facebook / LinkedIn -->
<meta property="og:title" content="Frequência 20/20 — by Prof. Peterson Brito">
<meta property="og:description" content="Sweep 20Hz–20kHz + ruído branco e rosa. Ferramenta didática para áudio, música e percepção.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://petersonbritoarte-code.github.io/sweep-20-20k/">
<meta property="og:image" content="https://petersonbritoarte-code.github.io/sweep-20-20k/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Frequência 20/20 — by Prof. Peterson Brito">
<meta name="twitter:description" content="Sweep 20Hz–20kHz + ruído branco e rosa. Ferramenta didática para áudio, música e percepção.">
<meta name="twitter:image" content="https://petersonbritoarte-code.github.io/sweep-20-20k/og-image.png">

  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Freq 20/20">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <style>
    :root{ color-scheme: dark; --accent:#8bd3ff; }
    *{ box-sizing:border-box; }

    body{
      margin:0;
      background:#000;
      min-height:100svh;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding: calc(14px + env(safe-area-inset-top)) 14px calc(14px + env(safe-area-inset-bottom));
    }

    .stage{
      width:min(980px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    .center{
      width:100%;
      text-align:center;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
    }

    /* Canal (clicável) – link simples (o iOS/Android decide se abre no app) */
    #brandTop{
      display:inline-block;
      font-size:18px;
      font-weight:900;
      color:#fff;
      opacity:.95;
      letter-spacing:.4px;
      text-decoration: underline;
      text-underline-offset: 4px;
      margin-top:2px;
    }
    #brandTop:active{ opacity:.75; }

    #modeLabel{
      font-size:13px;
      color:#9aa0a6;
      margin-top:-2px;
    }

    #bandLabel{
      font-size:18px;
      font-weight:900;
      letter-spacing:.7px;
      text-transform:uppercase;
      color:var(--accent);
    }

    #freq{
      font-family:ui-monospace,Menlo,Consolas,monospace;
      font-size:clamp(72px,12vw,140px);
      font-weight:950;
      color:var(--accent);
      line-height:1;
      text-shadow: 0 0 18px rgba(255,255,255,.06);
    }

    #bandTip{
      max-width:900px;
      font-size:16px;
      color:#b8bcc1;
      line-height:1.45;
      min-height:2.6em;
      padding:0 8px;
    }

    .safety{
      width:100%;
      max-width:920px;
      margin-top:4px;
      padding:12px 14px;
      border-radius:16px;
      border:1px solid #2a1f00;
      background:#0f0c00;
      color:#e8eaed;
      font-size:14px;
      line-height:1.4;
    }
    .safety strong{ color:#ffd36a; }

    .controls{
      width:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
      margin-top:4px;
    }

    .rowBtns{
      display:flex;
      gap:14px;
      justify-content:center;
      flex-wrap:wrap;
    }

    button{
      appearance:none;
      border:1px solid #2b2b2b;
      background:#111;
      color:#e8eaed;
      padding:14px 22px;
      border-radius:18px;
      font-weight:900;
      cursor:pointer;
      font-size:16px;
    }
    button:hover{ background:#151515; }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .modeRow{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      width:100%;
    }

    .modeBtn{
      padding:10px 14px;
      font-size:14px;
      border-radius:16px;
      font-weight:900;
      background: rgba(17,17,17,.9);
    }
    .modeBtn.active{
      border-color: var(--accent);
      box-shadow: 0 0 18px rgba(255,255,255,.06);
    }

    .box{
      width:100%;
      max-width:860px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
      padding:12px 14px;
      border:1px solid #1f1f1f;
      background: rgba(10,10,10,.75);
      backdrop-filter: blur(6px);
      border-radius:16px;
      color:#c9cdd1;
      font-size:14px;
    }

    input[type="range"]{
      width:340px;
      touch-action: pan-y;
    }

    .mono{
      font-family:ui-monospace,Menlo,Consolas,monospace;
      color:#e8eaed;
      font-weight:900;
    }

    .infoPanel{
      width:100%;
      max-width:860px;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:12px 14px;
      border:1px solid #1f1f1f;
      background: rgba(10,10,10,.65);
      backdrop-filter: blur(6px);
      border-radius:16px;
      color:#c9cdd1;
      margin-top:2px;
    }

    .infoRow{
      display:flex;
      justify-content:center;
      flex-wrap:wrap;
      gap:10px 14px;
      font-size:13px;
    }

    .chip{
      display:flex;
      gap:8px;
      align-items:center;
      padding:8px 10px;
      border:1px solid #1f1f1f;
      border-radius:14px;
      background: rgba(0,0,0,.25);
    }

    .dot{
      width:10px;height:10px;border-radius:50%;
      background:var(--accent);
      box-shadow: 0 0 14px rgba(255,255,255,.08);
    }
.splash{
  position:fixed; inset:0;
  display:flex; align-items:center; justify-content:center;
  background:#000;
  z-index:99999;
  transition: opacity .25s ease;
}
.splash.hide{ opacity:0; pointer-events:none; }
.splash.gone{ display:none; }
.splashCard{
  text-align:center;
  padding:18px 20px;
}
.splashIcon{
  width:86px; height:86px;
  border-radius:18px;
  margin-bottom:12px;
}
.splashTitle{
  font-weight:950;
  font-size:20px;
  color:#fff;
  letter-spacing:.2px;
}
.splashSub{
  margin-top:4px;
  color:#b8bcc1;
  font-size:14px;
}
    @media (max-width: 720px){
      #brandTop{ font-size:16px; }
      #bandLabel{ font-size:15px; }
      #bandTip{ font-size:14px; }
      .safety{ font-size:13px; }
      input[type="range"]{ width:min(260px, 78vw); }
      #freq{ font-size:clamp(56px,16vw,92px); }
    }
input[type="range"].disabled{
  opacity:.45;
  filter: grayscale(1);
}
/* Botões de modo com cor sólida */
.modeBtn.whiteSolid,
.modeBtn.pinkSolid{
  transition: all .15s ease;
}

.modeBtn.whiteSolid{
  background:#ffffff !important;
  color:#000000 !important;
  border-color:#ffffff !important;
}

.modeBtn.pinkSolid{
  background:#ff6ec7 !important;
  color:#000000 !important;
  border-color:#ff6ec7 !important;
}

/* ===== Estado ativo ===== */
.modeBtn.whiteSolid.active{
  border: 3px solid #bdbdbd !important;
  box-shadow: 0 0 0 3px rgba(255,255,255,.25);
  transform: scale(0.97);
}

.modeBtn.pinkSolid.active{
  border: 3px solid #c2185b !important;
  box-shadow: 0 0 0 3px rgba(255,110,199,.35);
  transform: scale(0.97);
}
  </style>
</head>

<body>
<div id="splash" class="splash" aria-hidden="true">
  <div class="splashCard">
    <img src="icons/icon-192.png" alt="Frequência 20/20" class="splashIcon">
    <div class="splashTitle">Frequência 20/20</div>
    <div class="splashSub">by Prof. Peterson Brito</div>
  </div>
</div>

<div class="stage">

    <div class="center">
      <a id="brandTop" href="https://www.youtube.com/@ProfPetersonBrito" target="_blank" rel="noopener noreferrer">
        youtube.com/@ProfPetersonBrito
      </a>

      <div id="modeLabel">Modo: <span class="mono" id="modeName">SWEEP</span></div>

      <div id="bandLabel">SUBGRAVE (20–40 Hz)</div>
      <div id="freq">20 Hz</div>
      <div id="bandTip">Sensação física e “peso”. Mais sentido no corpo do que no ouvido.</div>

      <div class="safety">
        <strong>Segurança:</strong>
        Comece com volume baixo. Sweeps/ruídos podem ficar agressivos em 2–5 kHz.
        Evite fones no máximo, faça pausas e interrompa ao menor sinal de desconforto.
        O “dBFS” exibido é ganho digital (não é SPL). <strong>iPhone/iPad:</strong> se estiver no modo silencioso, o Safari pode mutar o áudio.
      </div>
    </div>

    <div class="controls">
      <div class="modeRow">
        <button class="modeBtn active" id="modeSweep" type="button">Sweep</button>
        <button class="modeBtn" id="modeWhite" type="button">Branco</button>
        <button class="modeBtn" id="modePink"  type="button">Rosa</button>
      </div>

      <div class="rowBtns">
        <button id="startBtn" type="button">Iniciar</button>
        <button id="stopBtn" type="button" disabled>Parar</button>
      </div>

      <div class="box">
        <span>Volume</span>
        <input id="vol" type="range" min="0" max="1" step="0.001" value="0.08">
        <b id="volLabel" class="mono">8%</b>
      </div>

      <div class="box">
        <span>Posição</span>
        <input id="seek" type="range" min="0" max="300" step="0.01" value="0">
        <b id="seekLabel" class="mono">00:00 / 05:00</b>
        <span style="color:#9aa0a6;">•</span>
        <span>Prog.</span>
        <b id="progInfo" class="mono">0%</b>
      </div>

      <div class="infoPanel">
        <div class="infoRow">
          <div class="chip"><span class="dot"></span><span>Sinal</span><b id="signalInfo" class="mono">SWEEP</b></div>
          <div class="chip"><span>Curva</span><b id="curveInfo" class="mono">LOG</b></div>
        </div>
        <div class="infoRow">
          <div class="chip"><span>Sample rate</span><b id="srInfo" class="mono">—</b></div>
          <div class="chip"><span>Ganho</span><b id="gainInfo" class="mono">—</b></div>
          <div class="chip"><span>Qualidade</span><b class="mono">Float32 / WebAudio</b></div>
        </div>
      </div>
    </div>

  </div>

<script>
(() => {
  // ====== CONFIG ======
  const fStart = 20, fEnd = 20000, duration = 300;

  const BANDS = [
    { n:"Subgrave",    min:20,   max:40,      c:"#8bd3ff", t:"Sensação física e “peso”. Mais sentido no corpo do que no ouvido." },
    { n:"Grave-Baixo", min:40,   max:80,      c:"#66e0ff", t:"Fundação do grave. Base rítmica e sustentação do low-end." },
    { n:"Grave-Alto",  min:80,   max:200,     c:"#4ff2d6", t:"Punch e impacto. Excesso aqui costuma embolar/mascarar." },
    { n:"Médio-Grave", min:200,  max:500,     c:"#72ff7a", t:"Corpo e ressonância (“boxy”). Pode soar abafado se exagerar." },
    { n:"Médio-Médio", min:500,  max:1500,    c:"#cfff6a", t:"Centro do timbre. Dá “leitura”, mas pode ficar nasal/duro." },
    { n:"Médio-Agudo", min:1500, max:5000,    c:"#ffe66a", t:"Presença e inteligibilidade. Região sensível do ouvido: cuidado." },
    { n:"Agudo",       min:5000, max:12000,   c:"#ffb86a", t:"Brilho e ataque. Pode evidenciar sibilância/aspereza." },
    { n:"Super-Agudo", min:12000,max:20000.1, c:"#ff4d4d", t:"“Ar” e cintilância. Fácil causar fadiga em volumes altos." }
  ];

  // ====== UI ======
  const freqEl = document.getElementById("freq");
  const bandEl = document.getElementById("bandLabel");
  const tipEl  = document.getElementById("bandTip");

  const startBtn = document.getElementById("startBtn");
  const stopBtn  = document.getElementById("stopBtn");

  const vol = document.getElementById("vol");
  const volLabel = document.getElementById("volLabel");

  const seek = document.getElementById("seek");
  const seekLabel = document.getElementById("seekLabel");
  const progInfo = document.getElementById("progInfo");

  const srInfo   = document.getElementById("srInfo");
  const gainInfo = document.getElementById("gainInfo");

  const modeName   = document.getElementById("modeName");
  const signalInfo = document.getElementById("signalInfo");
  const curveInfo  = document.getElementById("curveInfo");

  const modeSweepBtn = document.getElementById("modeSweep");
  const modeWhiteBtn = document.getElementById("modeWhite");
  const modePinkBtn  = document.getElementById("modePink");

  modeWhiteBtn.classList.add("whiteSolid");
  modePinkBtn.classList.add("pinkSolid");

  // ====== AUDIO ======
  let ctx = null, gain = null, osc = null, noiseSrc = null;
  let raf = null, tStart = 0, tEnd = 0;

  let whiteBuf = null, pinkBuf = null;

  // ====== STATE ======
  let offsetSec = 0;
  let isRunning = false;
  let lastBand = -1;
  let mode = "sweep"; // sweep | white | pink

  // ====== UTILS ======
  function pad2(n){ return String(n).padStart(2,"0"); }
  function fmtTime(sec){
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec/60), s = sec%60;
    return `${pad2(m)}:${pad2(s)}`;
  }
  function fmtHz(f){ return Math.round(f).toLocaleString("pt-BR") + " Hz"; }
  function gainToDbfs(g){
    const x = Math.max(0.000001, g);
    return 20 * Math.log10(x);
  }
  function freqAt(t){
    const p = Math.min(Math.max(t / duration, 0), 1);
    return fStart * Math.pow(fEnd/fStart, p);
  }
  function bandIndexFor(f){
    for (let i=0;i<BANDS.length;i++){
      const b=BANDS[i];
      if (f>=b.min && f<b.max) return i;
    }
    return BANDS.length-1;
  }
  function applyBand(i){
    const b = BANDS[i];
    const maxShown = (b.max>20000) ? "20.000" : String(Math.round(b.max));
    bandEl.textContent = `${b.n.toUpperCase()} (${b.min}–${maxShown} Hz)`;
    tipEl.textContent = b.t;
    document.documentElement.style.setProperty("--accent", b.c);
  }
  function updateSeekUI(t){
    const p = Math.min(Math.max(t / duration, 0), 1);
    seekLabel.textContent = `${fmtTime(t)} / ${fmtTime(duration)}`;
    progInfo.textContent = `${Math.round(p*100)}%`;
  }
  function previewSweepAt(t){
    const f = freqAt(t);
    freqEl.textContent = fmtHz(f);

    const bi = bandIndexFor(f);
    if (bi !== lastBand){
      applyBand(bi);
      lastBand = bi;
    }
    updateSeekUI(t);
  }
  function previewNoise(){
    const isWhite = (mode === "white");
    const accent = isWhite ? "#ffffff" : "#ff6ec7";

    document.documentElement.style.setProperty("--accent", accent);

    freqEl.textContent = "—";
    bandEl.textContent = isWhite ? "RUÍDO BRANCO" : "RUÍDO ROSA";
    tipEl.textContent = isWhite
      ? "Energia igual por Hz. Útil para demonstrar hiss, espectro e percepção de brilho."
      : "Energia por oitava (≈ -3 dB/oitava). Soa mais “equilibrado” ao ouvido; ótimo para referência.";

    // ruído não tem “posição”
    seekLabel.textContent = `00:00 / ${fmtTime(duration)}`;
    progInfo.textContent = "—";
  }
  function setRunning(r){
    isRunning = r;
    startBtn.disabled = r;
    stopBtn.disabled  = !r;
  }

  // ===== iOS/Safari resume (sem await) =====
  function ensureCtx(){
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    return ctx;
  }
  function resumeCtxThen(cb){
    ensureCtx();

    const doUnlock = () => {
      try{
        const buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
        const src = ctx.createBufferSource();
        src.buffer = buffer;
        src.connect(ctx.destination);
        src.start(0);
        src.stop(0.01);
      }catch(e){}
    };

    const go = () => { doUnlock(); cb(); };

    if (ctx.state === "suspended") ctx.resume().then(go).catch(go);
    else go();
  }
  function ensureGain(){
    if (!gain){
      gain = ctx.createGain();
      gain.connect(ctx.destination);
    }
  }
  function stopSources(){
    if (!ctx) return;
    const now = ctx.currentTime;

    if (gain){
      gain.gain.cancelScheduledValues(now);
      gain.gain.setValueAtTime(gain.gain.value, now);
      gain.gain.linearRampToValueAtTime(0.00001, now + 0.03);
    }

    try{ if (osc) osc.stop(now + 0.04); }catch(e){}
    try{ if (noiseSrc) noiseSrc.stop(now + 0.04); }catch(e){}

    osc = null;
    noiseSrc = null;

    if (raf) cancelAnimationFrame(raf);
    raf = null;
  }

  // ===== Noise buffers =====
  function makeWhiteBuffer(seconds=2){
    const len = Math.floor(ctx.sampleRate * seconds);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i=0;i<len;i++) data[i] = (Math.random()*2 - 1) * 0.6;
    return buf;
  }
  function makePinkBuffer(seconds=3){
    const len = Math.floor(ctx.sampleRate * seconds);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const out = buf.getChannelData(0);

    let b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;

    for (let i=0; i<len; i++){
      const white = Math.random()*2 - 1;

      b0 = 0.99886 * b0 + white * 0.0555179;
      b1 = 0.99332 * b1 + white * 0.0750759;
      b2 = 0.96900 * b2 + white * 0.1538520;
      b3 = 0.86650 * b3 + white * 0.3104856;
      b4 = 0.55000 * b4 + white * 0.5329522;
      b5 = -0.7616 * b5 - white * 0.0168980;
      const pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
      b6 = white * 0.115926;

      out[i] = (pink * 0.11);
    }
    return buf;
  }
  function ensureNoiseBuffers(){
    if (!whiteBuf) whiteBuf = makeWhiteBuffer(2);
    if (!pinkBuf)  pinkBuf  = makePinkBuffer(3);
  }

  // ===== Start/loops =====
  function startSweepFromOffset(newOffset){
    stopSources();
    ensureGain();

const g0 = Math.max(0.00001, Number(vol.value));
const nowG = ctx.currentTime;

// MUITO IMPORTANTE: limpa automações antigas (fade-out etc.)
gain.gain.cancelScheduledValues(nowG);
gain.gain.setValueAtTime(g0, nowG);

    offsetSec = Math.min(Math.max(newOffset, 0), duration);
    seek.value = String(offsetSec);

    if (offsetSec >= duration){
      previewSweepAt(duration);
      setRunning(false);
      return;
    }

    osc = ctx.createOscillator();
    osc.type = "sine";
    osc.connect(gain);

    const now = ctx.currentTime;
    tStart = now + 0.05;
    const remaining = duration - offsetSec;
    tEnd = tStart + remaining;

    const f0 = freqAt(offsetSec);
    osc.frequency.setValueAtTime(f0, tStart);
    osc.frequency.exponentialRampToValueAtTime(fEnd, tEnd);

    srInfo.textContent = `${Math.round(ctx.sampleRate)} Hz`;
    gainInfo.textContent = `${g0.toFixed(3)} (≈ ${gainToDbfs(g0).toFixed(1)} dBFS)`;

    previewSweepAt(offsetSec);

    osc.start(tStart);
    osc.stop(tEnd);

    setRunning(true);
    raf = requestAnimationFrame(loopSweep);
  }

  function startNoise(){
    stopSources();
    ensureGain();
    ensureNoiseBuffers();

const g0 = Math.max(0.00001, Number(vol.value));
const nowG = ctx.currentTime;

// limpa automações antigas
gain.gain.cancelScheduledValues(nowG);
gain.gain.setValueAtTime(g0, nowG);

    noiseSrc = ctx.createBufferSource();
    noiseSrc.buffer = (mode === "white") ? whiteBuf : pinkBuf;
    noiseSrc.loop = true;
    noiseSrc.connect(gain);

    srInfo.textContent = `${Math.round(ctx.sampleRate)} Hz`;
    gainInfo.textContent = `${g0.toFixed(3)} (≈ ${gainToDbfs(g0).toFixed(1)} dBFS)`;

    previewNoise();
    noiseSrc.start();

    setRunning(true);
    raf = requestAnimationFrame(loopNoiseUI);
  }

  function loopNoiseUI(){
    if (!ctx || !gain || !isRunning) return;
    const g = gain.gain.value;
    gainInfo.textContent = `${g.toFixed(3)} (≈ ${gainToDbfs(g).toFixed(1)} dBFS)`;
    raf = requestAnimationFrame(loopNoiseUI);
  }

  function loopSweep(){
    if (!ctx || !osc) return;

    const now = ctx.currentTime;
    const t = offsetSec + (now - tStart);

    previewSweepAt(Math.min(Math.max(t,0), duration));

    const g = gain ? gain.gain.value : Number(vol.value);
    gainInfo.textContent = `${g.toFixed(3)} (≈ ${gainToDbfs(g).toFixed(1)} dBFS)`;

    if (now < tEnd) raf = requestAnimationFrame(loopSweep);
    else{
      offsetSec = duration;
      setRunning(false);
      stopSources();
      previewSweepAt(duration);
    }
  }

  // ===== Mode switch =====
function setMode(newMode){
  mode = newMode;

  modeSweepBtn.classList.toggle("active", mode === "sweep");
  modeWhiteBtn.classList.toggle("active", mode === "white");
  modePinkBtn.classList.toggle("active",  mode === "pink");

  if (mode === "sweep"){
    modeName.textContent = "SWEEP";
    signalInfo.textContent = "SWEEP";
    curveInfo.textContent = "LOG";
    modeName.style.color = "";
    previewSweepAt(Number(seek.value));
  } else if (mode === "white") {
modeName.textContent = "RUÍDO BRANCO (White Noise)";
signalInfo.textContent = "RUÍDO BRANCO (White Noise)";
    curveInfo.textContent = "—";
    modeName.style.color = "#ffffff";
    previewNoise();
  } else {
modeName.textContent = "RUÍDO ROSA (Pink Noise)";
signalInfo.textContent = "RUÍDO ROSA (Pink Noise)";
    curveInfo.textContent = "—";
    modeName.style.color = "#ff6ec7";
    previewNoise();
// habilita/desabilita o seek conforme modo
seek.disabled = (mode !== "sweep");
seek.classList.toggle("disabled", mode !== "sweep");
  }

  // ===== Troca automática do áudio ao mudar de modo =====
  if (isRunning) {
    resumeCtxThen(() => {
      if (mode === "sweep") {
        startSweepFromOffset(Number(seek.value));
      } else {
        startNoise();
      }
    });
  }
}

  function startAction(){
    resumeCtxThen(() => {
      ensureCtx();
      ensureGain();
      ensureNoiseBuffers();

      if (mode === "sweep") startSweepFromOffset(Number(seek.value));
      else startNoise();
    });
  }

  // ===== Events =====
  vol.addEventListener("input", () => {
    const v = Number(vol.value);
    volLabel.textContent = Math.round(v*100) + "%";
    gainInfo.textContent = `${v.toFixed(3)} (≈ ${gainToDbfs(v).toFixed(1)} dBFS)`;
    if (gain && ctx){
      const now = ctx.currentTime;
      gain.gain.setTargetAtTime(Math.max(0.00001, v), now, 0.02);
    }
  });

  seek.addEventListener("input", () => {
    if (mode !== "sweep") return;
    offsetSec = Number(seek.value);
    if (!isRunning) previewSweepAt(offsetSec);
    else updateSeekUI(offsetSec);
  });

  seek.addEventListener("change", () => {
    if (mode !== "sweep") return;
    offsetSec = Number(seek.value);
    if (isRunning) startAction(); // recomeça do ponto
    else previewSweepAt(offsetSec);
  });

  // Start (pointerdown ajuda no iOS/Safari)
  startBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    startAction();
  }, { passive:false });

  startBtn.addEventListener("click", (e) => {
    e.preventDefault();
    startAction();
  });

  stopBtn.addEventListener("click", () => {
    stopSources();
    setRunning(false);
    srInfo.textContent = "—";

    if (mode === "sweep"){
      offsetSec = Number(seek.value);
      previewSweepAt(offsetSec);
    } else {
      previewNoise();
    }
  });

  modeSweepBtn.addEventListener("click", () => setMode("sweep"));
  modeWhiteBtn.addEventListener("click", () => setMode("white"));
  modePinkBtn.addEventListener("click", () => setMode("pink"));

  // ===== Init =====
  seek.max = String(duration);
  seek.value = "0";

  const gInit = Number(vol.value);
  volLabel.textContent = Math.round(gInit*100) + "%";
  gainInfo.textContent = `${gInit.toFixed(3)} (≈ ${gainToDbfs(gInit).toFixed(1)} dBFS)`;

  setMode("sweep");
  previewSweepAt(0);
  setRunning(false);
// ===== Splash =====
const splash = document.getElementById("splash");
const hideSplash = () => {
  if (!splash) return;
  splash.classList.add("hide");
  // depois do fade, remove do layout
  setTimeout(() => splash.classList.add("gone"), 300);
};

// some sozinho após carregar
window.addEventListener("load", () => setTimeout(hideSplash, 450));

// some ao primeiro toque/clique
["pointerdown","touchstart","mousedown","keydown"].forEach(evt => {
  window.addEventListener(evt, hideSplash, { once:true, passive:true });
});
})();
</script>

<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("./service-worker.js").catch(() => {});
    });
  }
</script>

</body>
</html>
